#!/usr/bin/env python3
"""
Terminal chat tool for interacting with LLMs via OpenRouter API.
"""

import os
import sys
import json
import signal
from pathlib import Path
from typing import List, Dict, Optional
import requests
from dotenv import dotenv_values
from rich.console import Console
from rich.markdown import Markdown
from rich.panel import Panel
from rich.live import Live
from rich.spinner import Spinner
from rich.prompt import Prompt, Confirm
from prompt_toolkit import PromptSession
from prompt_toolkit.key_binding import KeyBindings
from prompt_toolkit.keys import Keys
from prompt_toolkit.filters import Condition
import keyring


# Constants for keyring
KEYRING_SERVICE = "terminal-gpt"
KEYRING_USERNAME = "openrouter_api_token"

# Pricing table (per million tokens)
PRICING_TABLE = {
    "anthropic/claude-haiku-4.5": {"input": 1.00, "output": 5.00},
    "openai/gpt-5-mini": {"input": 0.25, "output": 2.00},
    "google/gemini-2.5-flash": {"input": 0.30, "output": 2.50},
}


class SetupWizard:
    """Interactive setup wizard for first-run configuration."""

    def __init__(self, console: Console):
        self.console = console

    def run(self, migrate_existing: bool = False) -> bool:
        """Run the setup wizard. Returns True if setup was successful."""
        # Check for existing configuration
        config_path = Path.home() / '.askrc'
        existing_config = {}
        existing_token = None

        if config_path.exists():
            existing_config = dotenv_values(config_path)
            existing_token = existing_config.get('API_TOKEN')

        if migrate_existing and existing_token:
            # Migration mode
            self.console.print(Panel(
                "[bold yellow]Migrate to Secure Storage[/bold yellow]\n\n"
                "This will move your API token from the file to your system keychain.",
                border_style="yellow"
            ))
            self.console.print()

            if not Confirm.ask("Migrate your API token to secure keychain storage?"):
                self.console.print("[yellow]Migration cancelled.[/yellow]")
                return False

            # Use existing token
            api_token = existing_token
            model = existing_config.get('LLM', 'anthropic/claude-3.5-haiku')

        else:
            # Fresh setup
            self.console.print(Panel(
                "[bold green]Welcome to Terminal GPT![/bold green]\n\n"
                "Let's set up your OpenRouter API configuration.\n"
                "Your API token will be stored securely in your system keychain.",
                border_style="green"
            ))
            self.console.print()

            return self._interactive_setup()

        # Save to keychain
        return self._save_to_keychain(api_token, model, existing_config, remove_from_file=True)

    def _interactive_setup(self) -> bool:
        """Interactive setup for new users."""
        # Get API token
        self.console.print("[bold]Step 1:[/bold] OpenRouter API Token")
        self.console.print("Get your API token from: [cyan]https://openrouter.ai/keys[/cyan]")
        api_token = Prompt.ask("Enter your OpenRouter API token", password=True)

        if not api_token:
            self.console.print("[red]API token is required. Setup cancelled.[/red]")
            return False

        # Get model preference
        self.console.print("\n[bold]Step 2:[/bold] Choose your default model")
        self.console.print("Popular models:")
        self.console.print("  1. [cyan]anthropic/claude-haiku-4.5[/cyan]")
        self.console.print("  2. [cyan]openai/gpt-5-mini[/cyan]")
        self.console.print("  3. [cyan]google/gemini-2.5-flash[/cyan]")
        self.console.print("  4. Custom model")

        choice = Prompt.ask("Select option", choices=["1", "2", "3", "4"], default="1")

        model_map = {
            "1": "anthropic/claude-haiku-4.5",
            "2": "openai/gpt-5-mini",
            "3": "google/gemini-2.5-flash"
        }

        if choice == "4":
            model = Prompt.ask("Enter model name (format: provider/model)")
        else:
            model = model_map[choice]

        return self._save_to_keychain(api_token, model, {})

    def _save_to_keychain(self, api_token: str, model: str, existing_config: dict, remove_from_file: bool = False) -> bool:
        """Save API token to keychain and update config file."""
        # Save to keychain
        try:
            keyring.set_password(KEYRING_SERVICE, KEYRING_USERNAME, api_token)
            self.console.print("\n[green]✓[/green] API token stored securely in system keychain")
        except Exception as e:
            self.console.print(f"\n[yellow]Warning:[/yellow] Could not store in keychain: {e}")
            self.console.print("Will save to ~/.askrc file instead (with 600 permissions)")
            # If keychain fails, we need to keep it in the file
            remove_from_file = False

        # Create/update config file
        config_path = Path.home() / '.askrc'
        try:
            with open(config_path, 'w') as f:
                f.write(f"# Terminal GPT Configuration\n")
                if remove_from_file:
                    f.write(f"# API token is stored securely in system keychain\n")
                    f.write(f"# (removed from this file for security)\n\n")
                else:
                    f.write(f"# API token is stored securely in system keychain\n\n")

                f.write(f"LLM={model}\n")
                f.write(f"RENDER_MARKDOWN={existing_config.get('RENDER_MARKDOWN', 'true')}\n")
                f.write(f"SHOW_PANELS={existing_config.get('SHOW_PANELS', 'true')}\n")

                # Only write API_TOKEN if keychain failed
                if not remove_from_file and api_token:
                    f.write(f"\n# Fallback: API token (consider running 'ask --setup' to migrate to keychain)\n")
                    f.write(f"API_TOKEN={api_token}\n")

            # Set secure permissions
            os.chmod(config_path, 0o600)
            self.console.print(f"[green]✓[/green] Configuration saved to {config_path}")

        except Exception as e:
            self.console.print(f"[red]Error:[/red] Could not create config file: {e}")
            return False

        self.console.print("\n[bold green]Setup complete![/bold green] You can now use [cyan]ask[/cyan] to chat.")
        return True


class Config:
    """Configuration manager for the ask tool."""

    def __init__(self):
        self.llm: Optional[str] = None
        self.api_token: Optional[str] = None
        self.render_markdown: bool = True
        self.show_panels: bool = True
        self.show_cost: bool = False
        self.token_source: str = "unknown"  # Track where token came from
        self._load_config()

    def _load_config(self):
        """Load configuration from ~/.askrc and ./.askrc, with local override."""
        # Load home config first
        home_config_path = Path.home() / '.askrc'
        config = {}

        if home_config_path.exists():
            config.update(dotenv_values(home_config_path))
            self._check_permissions(home_config_path)

        # Override with local config if exists
        local_config_path = Path.cwd() / '.askrc'
        if local_config_path.exists():
            config.update(dotenv_values(local_config_path))
            self._check_permissions(local_config_path)

        # Parse non-sensitive config
        self.llm = config.get('LLM')
        self.render_markdown = config.get('RENDER_MARKDOWN', 'true').lower() in ('true', '1', 'yes')
        self.show_panels = config.get('SHOW_PANELS', 'true').lower() in ('true', '1', 'yes')
        self.show_cost = config.get('SHOW_COST', 'false').lower() in ('true', '1', 'yes')

        # Load API token with priority: keychain > env var > file
        self.api_token = self._load_api_token(config)

        # Check for migration opportunity
        if config.get('API_TOKEN') and self.token_source == "file":
            self._suggest_migration(config.get('API_TOKEN'))

        # Validate required fields
        if not self.llm or not self.api_token:
            # Missing config, trigger setup
            raise ValueError("Configuration incomplete")

    def _load_api_token(self, config: dict) -> Optional[str]:
        """Load API token from keychain, environment, or file (in that order)."""
        # Try keychain first
        try:
            token = keyring.get_password(KEYRING_SERVICE, KEYRING_USERNAME)
            if token:
                self.token_source = "keychain"
                return token
        except Exception:
            pass  # Keychain not available or failed

        # Try environment variable
        token = os.getenv('ASK_API_TOKEN')
        if token:
            self.token_source = "environment"
            return token

        # Fall back to file (less secure)
        token = config.get('API_TOKEN')
        if token:
            self.token_source = "file"
            return token

        return None

    def _suggest_migration(self, file_token: str):
        """Suggest migrating plain text token to keychain."""
        console = Console()
        console.print(
            "\n[yellow]Security Notice:[/yellow] Your API token is stored in plain text.\n"
            "Run [cyan]ask --setup[/cyan] to migrate to secure keychain storage.\n",
            style="yellow"
        )

    def _check_permissions(self, path: Path):
        """Warn if config file has insecure permissions."""
        stat_info = path.stat()
        mode = stat_info.st_mode & 0o777

        if mode != 0o600:
            print(f"Warning: {path} has insecure permissions {oct(mode)}. Recommend: chmod 600 {path}",
                  file=sys.stderr)


class CostTracker:
    """Tracks API usage costs."""

    def __init__(self, model: str):
        self.model = model
        self.total_input_tokens = 0
        self.total_output_tokens = 0
        self.pricing = PRICING_TABLE.get(model)

    def add_usage(self, input_tokens: int, output_tokens: int):
        """Add token usage to the tracker."""
        self.total_input_tokens += input_tokens
        self.total_output_tokens += output_tokens

    def get_cost(self) -> Optional[Dict[str, float]]:
        """Calculate total cost. Returns None if pricing not available."""
        if not self.pricing:
            return None

        input_cost = (self.total_input_tokens / 1_000_000) * self.pricing["input"]
        output_cost = (self.total_output_tokens / 1_000_000) * self.pricing["output"]
        total_cost = input_cost + output_cost

        return {
            "input_tokens": self.total_input_tokens,
            "output_tokens": self.total_output_tokens,
            "input_cost": input_cost,
            "output_cost": output_cost,
            "total_cost": total_cost
        }

    def format_cost(self) -> str:
        """Format cost information for display."""
        cost = self.get_cost()
        if not cost:
            return ""

        return (
            f"Tokens: {cost['input_tokens']:,} in / {cost['output_tokens']:,} out | "
            f"Cost: ${cost['total_cost']:.4f} (${cost['input_cost']:.4f} + ${cost['output_cost']:.4f})"
        )


class ConversationManager:
    """Manages conversation history with sliding window."""

    def __init__(self, max_messages: int = 20):
        self.messages: List[Dict[str, str]] = []
        self.max_messages = max_messages

    def add_message(self, role: str, content: str):
        """Add a message to the conversation history."""
        self.messages.append({"role": role, "content": content})
        self._apply_sliding_window()

    def _apply_sliding_window(self):
        """Keep first message (if it's a system message) and last N messages."""
        if len(self.messages) <= self.max_messages:
            return

        # Check if first message is a system message
        if self.messages[0]["role"] == "system":
            # Keep system message + last (max_messages - 1) messages
            self.messages = [self.messages[0]] + self.messages[-(self.max_messages - 1):]
        else:
            # Just keep last max_messages
            self.messages = self.messages[-self.max_messages:]

    def get_messages(self) -> List[Dict[str, str]]:
        """Get current conversation history."""
        return self.messages

    def clear(self):
        """Clear conversation history."""
        self.messages = []


class OpenRouterClient:
    """Client for OpenRouter API with streaming support."""

    def __init__(self, api_token: str, model: str):
        self.api_token = api_token
        self.model = model
        self.base_url = "https://openrouter.ai/api/v1/chat/completions"
        self.interrupted = False
        self.last_usage = None  # Store usage from last request

    def chat_stream(self, messages: List[Dict[str, str]]):
        """Stream chat completion from OpenRouter API. Yields content chunks."""
        self.last_usage = None  # Reset usage for new request
        headers = {
            "Authorization": f"Bearer {self.api_token}",
            "Content-Type": "application/json",
            "HTTP-Referer": "https://github.com/user/terminal-gpt",
            "X-Title": "Terminal GPT"
        }

        payload = {
            "model": self.model,
            "messages": messages,
            "stream": True
        }

        try:
            self.interrupted = False
            response = requests.post(
                self.base_url,
                headers=headers,
                json=payload,
                stream=True,
                timeout=30
            )

            if response.status_code != 200:
                error_msg = response.text
                try:
                    error_json = response.json()
                    error_msg = error_json.get('error', {}).get('message', error_msg)
                except:
                    pass
                raise Exception(f"API Error ({response.status_code}): {error_msg}")

            for line in response.iter_lines():
                if self.interrupted:
                    break

                if not line:
                    continue

                line = line.decode('utf-8')

                if line.startswith('data: '):
                    data = line[6:]

                    if data == '[DONE]':
                        break

                    try:
                        chunk = json.loads(data)

                        # Extract usage information if available
                        usage = chunk.get('usage')
                        if usage:
                            self.last_usage = {
                                'prompt_tokens': usage.get('prompt_tokens', 0),
                                'completion_tokens': usage.get('completion_tokens', 0),
                                'total_tokens': usage.get('total_tokens', 0)
                            }

                        delta = chunk.get('choices', [{}])[0].get('delta', {})
                        content = delta.get('content', '')

                        if content:
                            yield content

                    except json.JSONDecodeError:
                        continue

        except requests.exceptions.RequestException as e:
            raise Exception(f"Network error: {str(e)}")

    def interrupt(self):
        """Interrupt the current streaming request."""
        self.interrupted = True


class TerminalChat:
    """Main terminal chat interface."""

    def __init__(self, config: Config):
        self.config = config
        self.console = Console()
        self.conversation = ConversationManager()
        self.client = OpenRouterClient(config.api_token, config.llm)
        self.cost_tracker = CostTracker(config.llm) if config.show_cost else None
        self.session = PromptSession()
        self.interrupted = False

        # Setup signal handlers
        signal.signal(signal.SIGINT, self._handle_sigint)

    def _handle_sigint(self, signum, frame):
        """Handle Ctrl-C gracefully."""
        self.console.print("\n\nGoodbye!", style="bold yellow")
        sys.exit(0)

    def _setup_keybindings(self) -> KeyBindings:
        """Setup custom key bindings for input."""
        kb = KeyBindings()

        @kb.add(Keys.Escape)
        def _(event):
            """Handle ESC key to interrupt streaming."""
            self.interrupted = True
            self.client.interrupt()

        return kb

    def _get_user_input(self) -> Optional[str]:
        """Get multi-line user input (Shift+Enter for newline, Enter to send)."""
        try:
            # With multiline=False, Enter submits and the default behavior works
            # But we need to allow Shift+Enter for newlines, so use a custom approach
            from prompt_toolkit.key_binding import KeyBindings as KB

            kb = KB()

            # Enter without shift: accept input
            @kb.add('enter')
            def _(event):
                event.current_buffer.validate_and_handle()

            user_input = self.session.prompt(
                "> ",
                multiline=True,
                key_bindings=kb,
                prompt_continuation=lambda width, line_number, is_soft_wrap: '  '
            )
            return user_input.strip()

        except KeyboardInterrupt:
            return None
        except EOFError:
            return None

    def _is_exit_command(self, text: str) -> bool:
        """Check if text is an exit command."""
        return text.lower() in ('bye', 'quit', 'exit')

    def _display_response(self, content: str):
        """Display assistant response with optional markdown rendering."""
        if self.config.show_panels:
            if self.config.render_markdown:
                md = Markdown(content)
                self.console.print(Panel(md, border_style="blue"))
            else:
                self.console.print(Panel(content, border_style="blue"))
        else:
            if self.config.render_markdown:
                self.console.print(Markdown(content))
            else:
                self.console.print(content)

    def chat(self, initial_message: Optional[str] = None):
        """Start the chat conversation."""
        welcome_text = (
            f"[bold green]Terminal Chat[/bold green]\n"
            f"Model: [cyan]{self.config.llm}[/cyan]\n"
            f"Type [yellow]'bye', 'quit', or 'exit'[/yellow] to quit\n"
            f"Press [yellow]Shift+Enter[/yellow] for new line, [yellow]Enter[/yellow] to send\n"
            f"Press [yellow]ESC[/yellow] to interrupt response"
        )

        if self.config.show_panels:
            self.console.print(Panel(welcome_text, border_style="green"))
        else:
            self.console.print(welcome_text)
            self.console.print("─" * 60)

        # Handle initial message if provided
        if initial_message:
            self.console.print(f"\n[bold]You:[/bold] {initial_message}")
            self._process_message(initial_message)

        # Main conversation loop
        while True:
            self.console.print()
            user_input = self._get_user_input()

            if user_input is None:
                self.console.print("\nGoodbye!", style="bold yellow")
                break

            if not user_input:
                continue

            if self._is_exit_command(user_input):
                self.console.print("Goodbye!", style="bold yellow")
                break

            self._process_message(user_input)

    def _process_message(self, user_message: str):
        """Process a user message and get response."""
        # Add user message to conversation
        self.conversation.add_message("user", user_message)

        # Get streaming response
        self.interrupted = False
        assistant_response = ""

        try:
            self.console.print()

            # Stream the response
            with Live(console=self.console, refresh_per_second=10) as live:
                live.update(Spinner("dots", text="Thinking..."))

                first_chunk = True
                for chunk in self.client.chat_stream(self.conversation.get_messages()):
                    if self.interrupted:
                        self.console.print("\n[yellow]Response interrupted[/yellow]")
                        break

                    assistant_response += chunk

                    if first_chunk:
                        live.update("")
                        first_chunk = False

                    # Display current response
                    if self.config.show_panels:
                        if self.config.render_markdown:
                            live.update(Panel(Markdown(assistant_response),
                                            border_style="blue"))
                        else:
                            live.update(Panel(assistant_response,
                                            border_style="blue"))
                    else:
                        if self.config.render_markdown:
                            live.update(Markdown(assistant_response))
                        else:
                            live.update(assistant_response)

            # Add assistant response to conversation if not interrupted
            if not self.interrupted and assistant_response:
                self.conversation.add_message("assistant", assistant_response)

            # Track usage and display cost if enabled
            if self.cost_tracker and self.client.last_usage:
                self.cost_tracker.add_usage(
                    self.client.last_usage['prompt_tokens'],
                    self.client.last_usage['completion_tokens']
                )
                cost_info = self.cost_tracker.format_cost()
                if cost_info:
                    self.console.print(f"\n[dim]{cost_info}[/dim]")

        except Exception as e:
            self.console.print(f"\n[bold red]Error:[/bold red] {str(e)}", style="red")


def main():
    """Main entry point."""
    try:
        console = Console()

        # Check for --setup flag
        if len(sys.argv) > 1 and sys.argv[1] in ('--setup', '-s'):
            wizard = SetupWizard(console)
            if wizard.run():
                sys.exit(0)
            else:
                sys.exit(1)

        # Try to load configuration
        try:
            config = Config()
        except ValueError:
            # Configuration is incomplete, run setup wizard
            console.print("[yellow]Configuration incomplete. Running setup wizard...[/yellow]\n")
            wizard = SetupWizard(console)
            if not wizard.run():
                console.print("[red]Setup failed or cancelled.[/red]")
                sys.exit(1)

            # Try loading config again after setup
            config = Config()

        # Parse command line arguments
        initial_message = None
        if len(sys.argv) > 1:
            initial_message = ' '.join(sys.argv[1:])

        # Start chat
        chat = TerminalChat(config)
        chat.chat(initial_message)

    except KeyboardInterrupt:
        print("\nGoodbye!", file=sys.stderr)
        sys.exit(0)
    except Exception as e:
        print(f"Error: {str(e)}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
